module shader {
  import feature ;
  import generators ;
  import toolset ;
  import type ;
  import property ;

  type.register SHADER : vs vert vertex fs frag fragment gs geom geometry ;

  feature.feature shader-compiler : : free dependency ;
  feature.feature shader-name : : free ;
  feature.feature shader-templates : : free ;

  toolset.flags shader.compile COMPILER <shader-compiler> ;
  toolset.flags shader.compile PROGRAM <shader-name> ;
  toolset.flags shader.compile DESTINATION <location> ;
  toolset.flags shader.compile TEMPLATES <shader-templates> ;

  generators.register-composing shader.compile : SHADER : CPP(%_program_format) HPP(%_program_format) ;

  rule compile ( targets + : sources + : properties * ) {
    local templates = [ property.select <shader-templates> : $(properties) ] ;
    
    if ! $(templates) {
      local compiler = [ property.select <shader-compiler> : $(properties) ] ;
      local lproject = [ $(compiler:B).project ] ;
      templates = [ $(lproject).location ] ;
      templates = $(templates)/include/gtulu/templates/ ;
    }
        
    TEMPLATES on $(<) = $(templates) ;
  }
  
  actions compile bind COMPILER DESTINATION {
    $(COMPILER) -d $(DESTINATION) -p $(PROGRAM) -t $(TEMPLATES) $(>) 2>/dev/null >/dev/null
  }

  rule program ( name : sources + : properties * ) {
    cpp $(name) : $(sources) 
                : <shader-compiler>compiler
                  <shader-name>$(name) 
                  <location>generated/ 
                  <link>static 
                  $(properties) ;
  }
}