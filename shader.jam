module shader {
  import feature ;
  import generators ;
  import toolset ;
  import type ;
  import property ;

  type.register SHADER : vs vert vertex fs frag fragment gs geom geometry ;

  feature.feature shader-compiler : : free dependency ;
  feature.feature shader-name : : free ;
  feature.feature shader-templates : : free ;

  toolset.flags shader.compile COMPILER <shader-compiler> ;
  toolset.flags shader.compile PROGRAM <shader-name> ;
  toolset.flags shader.compile DESTINATION <location> ;
  toolset.flags shader.compile TEMPLATES <shader-templates> ;

  generators.register-composing shader.compile : SHADER CPP HPP : CPP(%_program_format) HPP(%_program_format) ;

  rule compile ( targets + : sources + : properties * ) {
    local templates = [ property.select <shader-templates> : $(properties) ] ;
    
    if ! $(templates) {
      local compiler = [ property.select <shader-compiler> : $(properties) ] ;
      local lproject = [ $(compiler:B).project ] ;
      templates = [ $(lproject).location ] ;
      templates = $(templates)/include/gtulu/templates/ ;
    }
    
    local shaders = "" ;
    for source in $(sources) {
      local type = [ type.type $(source) ] ;
      if $(type) = SHADER {
        shaders = $(shaders) $(source:G=) ;
      }
    }
        
    TEMPLATES on $(<) = $(templates) ;
    SOURCES on $(<) = $(shaders) ;
  }
  
  actions compile bind COMPILER DESTINATION {
    $(COMPILER) -d $(DESTINATION) -p $(PROGRAM) -t $(TEMPLATES) $(SOURCES) 2>/dev/null >/dev/null
  }

  rule program ( name : sources + : properties * ) {
    cpp $(name) : $(sources) ext/libgtulu/include/gtulu/templates/static_program_format.hpp
                : <shader-compiler>compiler
                  <shader-name>$(name) 
                  <location>generated/ 
                  <link>static 
                  $(properties) ;
  }
}